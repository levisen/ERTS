\documentclass[a4paper,12pt]{report}    %Article before

\usepackage{preamb}

\begin{document}
\lstset{style=output}
\input{latex/FrontPage.tex}
\tableofcontents
\pagestyle{ProjectReport}
\newpage
\lstlistoflistings
\newpage

\chapter{Assignment 1}
\section{Introduction}

bla bla systemc...






\section{ModuleSingle}

The first module implemented is a single threaded method run every 2ms. 

\lstset{style=code}
\lstinputlisting[language=C++, firstnumber=6, firstline=6, lastline=18, caption=Implementation of single.h header., label=31HEADER]{../code/src/assignment1/ModuleSingle/single.h}

\lstinputlisting[language=C++, firstnumber=4, firstline=4, lastline=14, caption=Implementation of single.cpp source., label=31SOURCE]{../code/src/assignment1/ModuleSingle/single.cpp}

As we are using a \textbf{sc\_uint<4>} type, the maximum for the counter will be \( 2^4 = 16 \). Which is noticed in the output \ref{31OUT}, whenever the counter reaches 15. As the counter goes from 0-15.

\lstset{style=output}
\lstinputlisting[firstline=12, lastline=17, caption=Output result from exercise 3.1., label=31OUT]{../code/src/assignment1/ModuleSingle/out/out}






\section{ModuleDouble}

For this exercise, we define the 4 events, 2 threads, and the method to be called from both threads in \ref{32HEADER}.

\lstset{style=code}
\lstinputlisting[language=C++, firstnumber=6, firstline=6, lastline=22, caption=Implementation of double.h header., label=32HEADER]{../code/src/assignment1/ModuleDouble/double.h}

Both of the threads are essentially implemented the same way. Just with different names shown in listing \ref{32SOURCE}. The \textbf{next\_trigger()} method is called to actively trigger the next event.

\lstinputlisting[language=C++, firstnumber=12, firstline=12, lastline=26, caption=Implementation of double.cpp source., label=32SOURCE]{../code/src/assignment1/ModuleDouble/double.cpp} 

In listing \ref{32OUT} it is seen that B is acknowledged every 2 ms, until a - that has a timeout period on 3 ms - gets called. Because A has catched up to 6ms and both ack should be called. B is skipped due to the thread's method is alternating. With the result of Back's next message being delivered at 8 ms.

\lstset{style=output}
\lstinputlisting[firstline=1, lastline=6, caption=Output result from exercise 3.2., label=32OUT]{../code/src/assignment1/ModuleDouble/out/out}





\section{ProducerConsumer}

Here, we are using the \textbf{sc\_fifo<>} type to initialize two \textbf{TCPHeader*} dummy instances, that represent the physical ports. 

\lstset{style=code}
\lstinputlisting[language=C++, firstnumber=8, firstline=8, lastline=27, caption=Initialization source for Producer Consumer implementation in SystemC., label=32HEADER]{../code/src/assignment1/ProducerConsumer/top.h}

The producer thread waits randomly and then generates a new \textbf{TCPHeader} instance to write to the \textbf{sc\_port}. Essentially the \textbf{TCPHeader} could be any dummy data object, that we want to transfer. Using the \textbf{package\_number} listed in \ref{33SOURCE::PRODUCER}, we incremented the package counter to keep track of sent packages to the consumers. The magic happens with the \textbf{sc\_fifo\_in<>} type, which clarifies the use of a FIFO port in SystemC. As shown in listing \ref{33SOURCE::CONSUMER}, the message from the physical port handled by SystemC, is consumed when the \textbf{read()} function is called.

\lstinputlisting[language=C++, firstnumber=4, firstline=4, lastline=15, caption=Implementation of producer.cpp source, label=33SOURCE::PRODUCER]{../code/src/assignment1/ProducerConsumer/producer.cpp}

\lstinputlisting[language=C++, firstnumber=4, firstline=4, lastline=9, caption=Implementation of consumer.cpp source, label=33SOURCE::CONSUMER]{../code/src/assignment1/ProducerConsumer/consumer.cpp}

The results listed in listing \ref{33OUT}, show the consumer name initialized in listing \ref{32HEADER}, sequence number and at which time the messages is generated and put to the queue. For some fun at the transport layer level, where this packages is typically used, we also added a random destination port.

\lstset{style=output}
\lstinputlisting[firstline=1, lastline=6, caption=Output result from exercise 3.3., label=33OUT]{../code/src/assignment1/ProducerConsumer/out/out}





\section{MasterSlave}



\end{document}
